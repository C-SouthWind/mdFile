# 多线程

github:https://github.com/C-SouthWind/multithreading

## 线程简介

### Process与Thread

- 说起进程，就不得不说下程序。程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念
- 而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位
- 通常在一个进程中可以包含若干个线程，当然一个进程至少有一个线程，不然没有存在的意义。线程是CPU调度和执行的单位

注意：很多多线程是模拟出来的，真正的多线程是指有多个cpu，即多核，如服务器。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错觉。

### 核心概念

- 线程就是独立的执行路径
- 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程
- main（）称之为主线程，为系统的入口，用于执行整个程序
- 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为干预的
- 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制
- 线程会带来额外的开销，如cpu调度时间，并发控制开销
- 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致



## 线程实现

### 线程创建

- 继承Thread类
  - 自定义线程类继承Thread类
  - 重写run（）方法，编写线程执行体
  - 创建线程对象，调用start（）方法启动线程
- 实现Runnable接口
  - 定义MyRunnable类实现Runnable接口
  - 实现run（）方法，编写线程执行体
  - 创建线程对象，调用start（）方法启动线程
- 实现Callable接口
  - 实现Callable接口，需要返回值类型
  - 重写call方法，需要抛出异常
  - 创建目标对象
  - 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool（1）
  - 提交执行：Future<Boolean> result = ser.submit（t1）
  - 获取结果：boolean ri = result1.get（）
  - 关闭服务：ser.shutdownNow（）



线程不一定立即执行，CPU安排调度

推荐使用Runnable对象，因为Java单继承的局限性

小结：

- 继承Thread类
  - 子类继承Thread类具备多线程能力
  - 启动线程：子类对象.start()
  - 不建议使用：避免oop单继承局限性
- 实现Runnable接口
  - 实现接口Runnable具有多线程能力
  - 启动线程：传入目标对象+Thread对象.start()
  - 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用



### Lambda表达式

- λ希腊字母表中排序第十一位的字母，英文名称为Lambda
- 避免匿名内部类定义过多
- 其实质属于函数式编程的概念

#### 为什么使用lambda表达式

- 避免匿名内部类定义过多
- 可以让你代码看起来很简洁
- 去掉了一堆没有意义的代码，只留下核心的逻辑
- 也许你会说，我看了Lambda表达式，不但不觉得简洁，反而觉得更乱，看不懂了。那是因为我们还没有习惯，用的多了，看习惯了，就好了

#### 理解Lambda

- 理解Functional Interface（函数式接口）是学习Java8 lambda表达式的关键所在
- 函数式接口的定义
  - 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。
    - public interface Runnable{  public abstract void run();  }
  - 对于函数式接口，我们可以通过lambda表达式来创建该接口的对象

```java
public class TestLambda2 {

    static class Love2 implements ILove{

        @Override
        public void love(String name) {
            System.out.println("I  Love  " + name);
        }
    }

    public static void main(String[] args) {
        ILove love = new Love();
        love.love("1");

        love = new Love2();
        love.love("2");

        class Love3 implements ILove{

            @Override
            public void love(String name) {
                System.out.println("I  Love  " + name);
            }
        }
        love = new Love3();
        love.love("3");

        love = new ILove() {
            @Override
            public void love(String name) {
                System.out.println("I  Love  " + name);
            }
        };
        love.love("4");


        love = (String name) ->{
            System.out.println("I  Love  " + name);
        };
        //简化lambda表达式1  去掉参数类型
        love = (name) ->{
            System.out.println("I  Love  " + name);
        };
        //简化lambda表达式2  去掉括号
        love = name->{
            System.out.println("I  Love  " + name);
        };
        //简化lambda表达式3  去掉花括号
        love = name->System.out.println("I  Love  " + name);

        //总结
        /**
         * lambda表达式只能有一行代码的情况下才能简化成为一行，如果有多行，那么就用代码块包裹
         * 前提是接口为函数表达式接口（接口中只有一个方法）
         * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号
         */
        love.love("5");
    }
}


interface ILove{
    void love(String name);
}

class Love implements ILove{

    @Override
    public void love(String name) {
        System.out.println("I  Love  " + name);
    }
}

```



## 线程状态

- 创建状态
  - 启动线程  Thread t = new Thread() 线程对象一旦创建就进入到新生状态
- 就绪状态
  - 当调用start()方法，线程立即进入就绪状态，但不意味着立即调度执行
  - 获得CPU资源进入运行状态
- 阻塞状态
  - 运行状态中调用sleep，wait或同步锁定时，线程进入阻塞状态，就是代码不往下执行，阻塞事件解除后，重新进入就绪状态，等待CPU调用
  - 阻塞解除进入就绪状态
- 运行状态
  - 进入运行状态，线程才真正执行线程体的代码快
  - 等待用户输入线程休眠等进入阻塞状态
  - 释放CPU资源进入就绪状态
- 死亡状态
- 线程中断或者结束，一旦进入死亡状态，就不能再次启动
  - 线程自然执行完毕外部干扰终止线程

### 线程方法

| 方法                             | 说明                                       |
| -------------------------------- | ------------------------------------------ |
| setPriority（int  newPriority）  | 更改线程的优先级                           |
| static void sleep（long millis） | 在指定的毫秒数内让当前正在执行的线程休眠   |
| void join（）                    | 等待该线程终止                             |
| static void yield（）            | 暂停当前正在执行的线程对象，并执行其他线程 |
| void interrupt（）               | 中断线程，别用这个方式                     |
| boolean isAlive（）              | 测试线程是否处于活动状态                   |

### 停止线程

- 不推荐使用JDK提供的stop（）、destory（）方法
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止变量，当flag=false，则终止线程运行

### 线程休眠

- sleep（时间）指定当前线程阻塞的毫秒数
- sleep存在异常interruptedException
- sleep时间达到后线程进入就绪状态
- sleep可以模拟网络延时，倒计时等
- 每一个对象都有一个锁，sleep不会释放锁

### 线程礼让

- 礼让线程，让当前正在执行的线程暂停，但吧阻塞
- 将线程从运行状态转为就绪状态
- 让cpu重新调度，礼让不一定成功！看cpu心情

### Join

- join合并线程，待此线程执行完毕后，再执行其他线程，其他线程阻塞
- 可以想象成插队

### 线程状态观测

- Thread.state
  - NEW
    - 尚未启动的线程处于此状态
  - RUNNABLE
    - 在java虚拟机中执行的线程处于此状态
  - BLOCKED
    - 被阻塞等待监视器锁定的线程处于此状态
  - WAITING
    - 正在等待另一个线程执行特定动作的线程处于此状态
  - TIMED_WAITING
    - 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态
  - TERMINATED
    - 已退出的线程处于此状态



### 线程优先级

- Java提供一个线程调度器来监控程序中启动后进入就绪状态的所以线程，线程调度器按照优先级决定应该调度哪个线程来执行
- 线程的优先级用数字表示，范围从1~10
  - Thread.MIN_PRIORITY=1
  - Thread.MAX_PRIORITY=10
  - Thread.NORM_PRIORITY=5
- 使用以下方式改变或获取优先级
  - getPriority().setPriority(int xxx)
  - 优先级的设定建议在start()调度前
  - 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看cpu的调度



### 守护（daemon）线程

- 线程分为用户线程和守护线程
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不要等待守护线程执行完毕
- 如，后台记录操作日志，监控内存，垃圾回收等待...





## 线程同步

- 由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入**锁机制synchronized**,当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：
  - 一个线程持有锁会导致其他所有需要此锁的线程挂起
  - 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延迟引起性能问题
  - 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题



### 同步方法

- 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：synchronized方法和synchronized块
  - 同步方法：public synchronized void method(int args){}
- synchronized方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占改锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行
  - 缺陷：若将一个大的方法申明为synchronized将会影响效率

### 同步块

- 同步块：synchronized（obj ）{}
- Obj 称之为 **同步监视器**
  - Obj 可以是任何对象，但是推荐使用共享资源作为同步监视器
  - 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class
- 同步监视器的执行过程
  - 第一个线程访问，锁定同步监视器，执行其中代码
  - 第二个线程访问，发现同步监视器被锁定，无法访问
  - 第一个线程访问完毕，解锁同步监视器
  - 第二个线程访问，方向同步监视器没有锁，然后锁定并访问



### 死锁

- 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形，某一个同步块同时拥有“**两个以上对象的锁**”时，就可能会发生死锁的问题

### 死锁避免方法

- 产生死锁的四个必要条件:
  - 互斥条件：一个资源每次只能被一个进程使用
  - 请求于保持条件：一个进程因请求资源而阻塞时，对已获得的资源保存不放
  - 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺
  - 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系



### Lock（锁）

- 从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当
- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象
- ReentrantLock类实现了Lock，它拥有于synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock,可以显式加锁、释放锁



### synchronized于lock的对比

- lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
- lock只有代码块锁，synchronized有代码块锁和方法锁
- 使用lock锁，jvm将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
- 优先使用顺序：
  - lock > t同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

## 线程通信问题

### 应用场景：生产者和消费者问题

- 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费
- 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库在的产品被消费者取走位置
- 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止
- producer（生产者） ----》数据缓存区 ----》 Consumer（消费者）

#### 分析

**这是一个线程同步问题，生产者和消费者共享一个资源，并且生产者和消费者之间相互依赖，互为条件**

- 对于生产者，没有生产产品之前，要通知消费者等待，而生产了产品之后，又需要马上通知消费者消费
- 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费
- 在生产者消费者问题中，仅有synchronized是不够的
  - synchronized可阻止并发更新同一个共享资源，实现同步
  - synchronized不能用来实现不同线程之间的消息传递（通信）

Java提供了几个方法解决线程之间的通信问题

| 方法名               | 作用                                                         |
| -------------------- | ------------------------------------------------------------ |
| wait（）             | 表示线程一直等待，直到其他线程通知，与sleep不同，会释放锁    |
| wait（long timeout） | 指定等待的毫秒数                                             |
| notify（）           | 唤醒一个处于等待状态的线程                                   |
| notifyAll（）        | 唤醒同一对象上所有调用wait（）方法的线程，优先级别高的线程优先调度 |

注意：均是Object类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常IllegalMonitorStateException



**解决方式一：**

并发协作模型“生产者/消费者模式” ---》管理法

- 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）
- 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）
- 缓冲区：消费者不能直接使用生产者的数据，他们之间有个“缓冲区”

**生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据**

解决方式二：

并发协作模型“生产者/消费者模式” ---》信号灯法



## 高级主题

### 线程池

- 背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大
- 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。类似生活中的公共交通工具
- 好处：
  - 提高相应速度（减少了创建新线程的时间）
  - 降低资源消耗（重复利用线程池中线程，不需要每次都创建）
  - 便于线程管理（...）
    - corePoolSize：核心池的大小
    - maximumPoolSize：最大线程数
    - keepAliveTime：线程没有任务时最多保持多长时间会终止
- JDK5.0起提供了线程池相关的API：ExecutorService和Executors
- ExecutorService：真正的线程池接口。常见的子类ThreadPoolEecutor
  - void execute（Runnable command）：执行任务/命令，没有返回值，一般用来执行Runnable
  - <T> Future<T> submit（Callanle<T> task）：执行任务，有返回值，一般又来执行Callable
  - void shutdown（）：关闭连接池
- Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池